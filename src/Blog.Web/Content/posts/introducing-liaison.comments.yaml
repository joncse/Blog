- Email: "graphite@joeyguerra.com"
  Message: "<p>This reminds me of a pub sub implementation, which of course, I LOVE!</p>"
  Name: "Joey Guerra"
  When: "2013-10-26 04:03:09.000"
- Email: "graphite@joeyguerra.com"
  Message: "<p>And I couldn't help but <a href=\"http://www.youtube.com/watch?v=b2F-DItXtZs\" rel=\"nofollow\">http://www.youtube.com/watch?v...</a> to the web scale link.</p>"
  Name: "Joey Guerra"
  When: "2013-10-26 14:41:41.000"
- Email: "khalidabuhakmeh@gmail.com"
  Message: "<p>This reminds me of what Fubu MVC is doing, where actions can be chained. I am still on the fence of whether I would use something like this or not, since the cognitive overhead might not be worth the addition of the code.</p>"
  Name: "khalidabuhakmeh"
  When: "2013-10-29 13:50:57.000"
- Email: "askafif@y7mail.com"
  Message: "<p>Have you looked at TInyMessenger (part of TinyIoC)? Its a more full fledged in memory bus with pub sub semantics, all rolled into one file.</p>"
  Name: "Afif Mohammed"
  When: "2013-12-08 22:16:47.000"
- Email: "disqus@wyldeye.com"
  Message: "<p>Nice. Thanks for the heads up.</p><p>Liaison is aiming to find a minimum level of abstraction. It's more an exercise in understanding than anything. For instance, just responding to this comment, I've thought of a couple way to further simplify my stack. :-]</p>"
  Name: "Kijana Woodard"
  When: "2013-12-09 21:29:55.000"
- Email: "askafif@y7mail.com"
  Message: "<p>And you're doing great. I love minimalism too, but often, in that pursuit I think I am probably going to miss out on important concerns that are there for a reason in other libraries. I am searching hard for a great in memory bus, that lets me do true event driven programming (think NSB API), where one can do a send and publish, and send is from 1 to many, handled by only one, and publish is from one and only one, handled by zero to many. The hardest I find in this pursuit is implementing Unit of work around the message handler, and still keeping it dead simple.</p>"
  Name: "Afif Mohammed"
  When: "2013-12-09 22:12:40.000"
- Email: "disqus@wyldeye.com"
  Message: "<p>Thanks.</p><p>I started this journey looking at NSB 4.0 \"In Memory Publish\" and realized I really wanted to do Send, which it didn't have. I didn't realize how far that would take me. :-]</p><p>I started out with nimbus (<a href=\"http://kijanawoodard.com/introducing-nimbus)\" rel=\"nofollow\">http://kijanawoodard.com/intro...</a> so that I could register handlers for messages anywhere, like nsb. What I quickly realized is that you get into cases like \"I need the handlers to run in a particular order\", \"This handler needs two parameters\", \"This handler needs zero parameters\", \"This handler uses the result of the work of the first 3 handlers (an Event)\".</p><p>Once there, I either needed to retreat to a \"full featured\" container, although that doesn't solve the ordering issue (see nsb's .First&lt;t&gt;(), etc), or I needed something else.</p><p>What I've found is that the \"orchestration code\" is fairly concise to write manually and keeps a lot of if/switch logic out of the handler code. Not to mention, I don't have to learn the incantations of the container.</p><p>I still owe you a blog post with more details and code. :-]</p>"
  Name: "Kijana Woodard"
  When: "2013-12-09 23:00:52.000"
- Email: "disqus@wyldeye.com"
  Message: "<p>Also, it's interesting that you wrote this, because I was thinking of adding a \"publish\" feature, which really amounts to allowing multiple subscriptions for a message.</p><p>I've tried not to impose concepts like Command vs Event and I think I can continue to do that, but allow \"send to many\".</p><p>I haven't decided whether it should just be Send -&gt; \"send to whatever is registered\" or if I should do something like Send -&gt; \"send to subscriptions[0]\" and Publish -&gt; \"send to all subscriptions\".</p><p>I'll write the code and let it decide. :-]</p>"
  Name: "Kijana Woodard"
  When: "2013-12-09 23:05:12.000"
- Email: "askafif@y7mail.com"
  Message: "<p>To be honest, at my last assignment, I did create an in memory pub sub mechanism to let the team get their head around event driven architecture without all the queues and distribution. We used that to move from procedural style to events and commands, and that paved the way for NSB to come in later. I am itching to write that again, but want to look around so I can borrow 'good' ideas, or even better just use something that fits the bill.</p>"
  Name: "Afif Mohammed"
  When: "2013-12-09 23:10:47.000"
- Email: "disqus@wyldeye.com"
  Message: "<p>I'm sorta pushing \"roll your own\" with this code since it's single file inclusion only.</p><p>I have used it in enough mini projects that I'm considering putting it on nuget just for my own sake. But I want to let the api settle a bit. I still think it's a bit bloated, if you can believe that.</p><p>The key to \"in memory publish\" in a web request is transactions. If we're honest, we really only get one. Beyond that you're pushing your luck or opening up a can of worms. If the request fatals, where are you? Can you restart? From which point?</p><p>So a real \"publish\" where \"this is an Event that happened in the past\" (meaning saved to disk somewhere for all time), isn't friendly in memory.</p><p>I _think_ I'd like to add a way for disconnected code to register \"background tasks\" within the same unit of work as the main request handler code. The background tasks would then carry out follow on options like \"send an email\", \"update the stats screen\", etc. I'm not sure that this use case is worth the mental disconnect of not being able to trivially see what's going to be saved when the commit occurs.</p>"
  Name: "Kijana Woodard"
  When: "2013-12-09 23:19:27.000"
- Email: "askafif@y7mail.com"
  Message: "<p>Also, the moment you have something that lets you do messaging, I feel its imperative to demonstrate the difference between command and event. Without that it feels messages are flying everywhere for no rhyme or reason. Hiding in the sheep's clothing of decoupling behind messages developers will write code that has all interesting side effects.</p>"
  Name: "Afif Mohammed"
  When: "2013-12-09 23:20:07.000"
- Email: "askafif@y7mail.com"
  Message: "<p>That looks familiar to what Oren has done with Racoon blog. Interesting thoughts.</p>"
  Name: "Afif Mohammed"
  When: "2013-12-09 23:22:09.000"
- Email: "disqus@wyldeye.com"
  Message: "<p>That's where I stole the idea.</p><p>Oren's Limit your Abstractions series is pivotal to my line of thinking on this. If I can drop IFoo, IGoo, IThisService, and IThatService and boil things down to IMediator (or whatever), clarity is what emerges.</p><p>I find the constraint similar to ReST constraints. At first you find it hampers you. But soon, you see that what you were doing before was \"making stuff up\" and not focusing on the essence of what needed to be done. At the end, your code becomes a tightly coupled mess of Interfaces that were suppose to solve the coupling problem but didn't because you just wrote the same old procedural spaghetti code hidden behind an interface.</p>"
  Name: "Kijana Woodard"
  When: "2013-12-09 23:30:46.000"
- Email: "askafif@y7mail.com"
  Message: "<p>Couldn't agree more.</p>"
  Name: "Afif Mohammed"
  When: "2013-12-09 23:38:58.000"
- Email: "disqus@wyldeye.com"
  Message: "<p>I know how you feel. Since I'm going for minimalism, I didn't want to impose that view _from_ Liaison. So if you want IEvent and ICommand and IHandle&lt;t&gt;, etc go ahead. Liaison won't _force_ you to do that, but it's easy to overlay. Plus, I didn't want to write \"unobtrusive mode\". :-]</p>"
  Name: "Kijana Woodard"
  When: "2013-12-09 23:48:16.000"

